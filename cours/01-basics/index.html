<!doctype html>
<html lang="fr">
    <head>
        <meta charset="utf-8">
        <title>Cours 01 - WebGL - Three.js</title>
        <meta name="description" content="">
        <meta name="author" content="Bruno Simon">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="stylesheet" href="../src/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../src/reveal.js/css/theme/orange.css" id="theme">
        <!-- <link rel="stylesheet" href="../src/reveal.js/lib/css/highlight/railscasts.css"> -->
        <!-- <link rel="stylesheet" href="../src/reveal.js/lib/css/highlight/github.css"> -->
        <link rel="stylesheet" href="../src/custom/style.css">
        <script>
            document.write( '<link rel="stylesheet" href="../src/reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>
        <!--[if lt IE 9]>
            <script src="../src/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->

        <!-- Code steps start -->
        <link rel="stylesheet" href="../src/code-steps/prism-tomorrow.css">
        <link rel="stylesheet" href="../src/code-steps/style.css">
        <!-- Code steps end -->
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>WebGL</h1>
                    <h3>Cours 01 - Basics</h3>
                    <ul>
                        <li>github :<br><a target="_blank" href="https://github.com/brunosimon/ecole-multimedia-fi-dev2">github.com/brunosimon/ecole-multimedia-fi-dev2</a></li>
                        <li>site :<br><a target="_blank" href="http://bruno-simon.com/ecole-multimedia/fi-dev2/">bruno-simon.com/ecole-multimedia/fi-dev2/</a></li>
                        <li>contact :<br><a target="_blank" mailto="simon.bruno.77@gmail.com">simon.bruno.77@gmail.com</a></li>
                    </ul>
                </section>

                <section>
                    <h1>WebGL</h1>
                    <h2 class="fragment">Avec Three.js</h2>
                </section>

                <section>
                    <h2>Qu'est-ce que le WebGL ?</h2>
                    <p class="fragment">API javascript permettant de faire des rendus 2D et 3D dans le browser en utilisant la puissance de la carte graphique</p>
                </section>

                <section>
                    <p>En r√©alit√©, le WebGL permet de dessiner une grande quantit√© de triangles tr√®s rapidement</p>
                </section>

                <section>
                    <ul>
                        <li>N√©cessite un canvas</li>
                        <li>WebGL utilise l'OpenGL</li>
                        <li>OpenGL utilise la carte graphique (GPU) pour faire des calculs, pour g√©rer des g√©om√©tries, des textures, des matrices, etc.</li>
                        <li>Acc√©l√©ration mat√©rielle</li>
                        <li>Permet aussi bien de faire de la 3D que de la 2D</li>
                    </ul>
                </section>

                <section>
                    <h2>√Ä quoi sert la carte graphique ?</h2>
                </section>
    
                <section>
                    <ul>
                        <li>Si un processeur devait traiter un rendu, il le ferait pixel par pixel</li>
                        <li>Une image de 800x600 comprend donc 480¬†000 pixels √† traiter un par un</li>
                        <li>Cela lui prendrait trop de temps et on ne pourrait avoir une animation fluide (60fps)</li>
                        <li>La carte graphique est capable de g√©rer des millions de calculs en parall√®le. Elle va donc g√©rer plusieurs millions de pixels simultan√©ment.</li>
                    </ul>
                </section>

                <section>
                    <h2>Compatibilit√©</h2>
                </section>

                <section>
                    <p><a href="http://caniuse.com/#feat=webgl" target="_blank">CanIUse</a></p>
                    <iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=webgl&periods=future_1,current,past_1,past_2,past_3,past_4" frameborder="0" width="800" height="467"></iframe>
                </section>

                <section>
                    <p>Peut n√©cessiter une carte graphique puissante<br>‚ö†Ô∏è Attention aux smartphones</p>
                </section>

                <section>
                    <h2>D√©monstrations</h2>
                </section>

                <section>
                    <ul>
                        <li><a href="https://www.orano.group/experience/innovation/fr" target="_blank">Orano</a> (Immersive Garden)</li>
                        <li><a href="https://thenewmobileworkforce.imm-g-prod.com/" target="_blank">The New Mobile Workforce</a> (Immersive Garden)</li>
                        <li><a href="https://cheshirecat.inthehiddencity.com/" target="_blank">Cheshire Cat</a> (Immersive Garden)</li>
                        <li><a href="https://prior.co.jp/discover/en" target="_blank">Prior</a> (Immersive Garden)</li>
                        <!-- <li><a href="http://i-remember.fr/" target="_blank">I Remember</a> (Edan Kwan)</li> -->
                        <li><a href="http://letsplay.ouigo.com/" target="_blank">OUIGO - Let's play</a> (Merci Michel)</li>
                        <li><a href="https://scars.forhonorgame.com/" target="_blank">For Honors - Scars</a> (Make me Pulse)</li>
                    </ul>
                </section>

                <section>
                    <ul>
                        <li><a href="https://playcanv.as/e/p/44MRmJRU/" target="_blank">After the Flood</a> (Firefox)</li>
                        <li><a href="https://2019.makemepulse.com/" target="_blank">Nomadic Tribe</a> (MakeMePulse)</li>
                        <li><a href="https://dogstudio.co/" target="_blank">Dog Studio</a> (Dog Studio)</li>
                        <li><a href="https://lusion.co/" target="_blank">Lusion</a> (Lusion)</li>
                        <li><a href="https://bruno-simon.com/" target="_blank">Portfolio</a> (Bruno Simon)</li>
                    </ul>
                </section>

                <section>
                    <h2>Faire du WebGL natif</h2>
                </section>

                <section>
                    <p>Exemple</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Canvas
 */
const canvas = document.createElement('canvas')
canvas.width = 600
canvas.height = 400
document.body.appendChild(canvas)

/**
 * GL context
 */
const gl = canvas.getContext('webgl')

gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
gl.clearColor(0, 0, 0, 0)
gl.clear(gl.COLOR_BUFFER_BIT)

/**
 * Shaders
 */

// Create shader function
const createShader = (_gl, _type, _source) =>
{
    // Compile
    const shader = _gl.createShader(_type)
    _gl.shaderSource(shader, _source)
    _gl.compileShader(shader)

    // Get success
    const success = _gl.getShaderParameter(shader, _gl.COMPILE_STATUS)

    if(success)
    {
        return shader
    }

    // Error
    console.warn('Error creatting shader', shader)
    _gl.deleteShader(shader)
}

// Shaders
const vertexShader = createShader(gl, gl.VERTEX_SHADER, `
    attribute vec2 aPosition;
    attribute vec4 aColor;

    uniform vec2 uResolution;

    varying vec4 vColor;

    void main()
    {
        vec2 zeroToOne = aPosition / uResolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1.0, - 1.0), 0.0, 1.0);

        vColor = aColor;
    }
`)

const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `
    precision mediump float;

    uniform vec4 uColor;

    varying vec4 vColor;

    void main()
    {
        gl_FragColor = vColor;
    }
`)

/**
 * Program
 */

// Create program function
const createProgram = (_gl, _vertexShader, _fragmentShader) =>
{
    // Link program
    const program = _gl.createProgram()
    _gl.attachShader(program, _vertexShader)
    _gl.attachShader(program, _fragmentShader)
    _gl.linkProgram(program)

    // Get success
    const success = gl.getProgramParameter(program, gl.LINK_STATUS)

    if(success)
    {
        return program
    }

    // Error
    console.warn('Error creatting program', program)
    _gl.deleteProgram(program)
}

const program = createProgram(gl, vertexShader, fragmentShader)
gl.useProgram(program)

/**
 * Uniforms
 */

// Resolution
const resolutionUniformLocation = gl.getUniformLocation(program, 'uResolution')
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height)

// Color
const colorUniformLocation = gl.getUniformLocation(program, 'uColor')
gl.uniform4f(colorUniformLocation, 1.0, 0.0, 1.0, 1.0)

/**
 * Attributes
 */

// Position
const positionBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)

const positionAttributeLocation = gl.getAttribLocation(program, 'aPosition')
gl.enableVertexAttribArray(positionAttributeLocation)
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0)

// Color
const colorBuffer = gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)

const colorAttributeLocation = gl.getAttribLocation(program, 'aColor')
gl.enableVertexAttribArray(colorAttributeLocation)
gl.vertexAttribPointer(colorAttributeLocation, 4, gl.UNSIGNED_BYTE, true, 0, 0)

/**
 * Draw shape
 */

// Position
const positions = [
    0, 0,
    100, 300,
    300,  100
]

gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)

// Color
const colors = [
    255, 0, 0, 255,
    0, 255, 0, 255,
    0, 0, 255, 255
]

gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW)

// Draw
gl.drawArrays(gl.TRIANGLES, 0, 3)
                        </code></pre>
                    </div>
                    <p><a target="_blank" href="./natif/">R√©sultat</a></p>
                </section>

                <section>
                    <p>Faire du WebGL natif, bien que tr√®s int√©ressant, demande trop de temps et d'effort. Nous allons plut√¥t utiliser la librairie <span class="hl">Three.js</span></p>
                </section>

                <section>
                    <h2>Three.js</h2>
                    <p>
                        Auteur: Ricardo Cabello (<a href="https://twitter.com/mrdoob" target="_blank">Mr. Doob</a>)
                        <ul>
                            <li><a href="https://twitter.com/threejs_org" target="_blank">Twitter</a></li>
                            <li><a href="https://threejs.org/" target="_blank">Site</a></li>
                            <li><a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene" target="_blank">Documentation</a></li>
                        </ul>
                    </p>
                </section>

                <section>
                    <h3>Si vous utilisez un bundler et NPM</h3>
                    <ul>
                        <li>
                            <p>Ajoutez la d√©pendance <a href="https://www.npmjs.com/package/three" target="_blank">three</a></p>
                            <div class="code-steps" data-type="bash" data-trim>
                                <pre contenteditable><code>
        npm install --save-dev three
                                </code></pre>
                            </div>
                        </li>
                        <li>
                            <p>puis importez Three.js dans votre script</p>
                            <div class="code-steps" data-type="js" data-trim>
                                <pre contenteditable><code>
import * as THREE from 'three'

// ...
                                </code></pre>
                            </div>
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Si vous n'utilisez pas un bundler et NPM</h3>
                    <ul>
                        <li>T√©l√©chargez Three.js <a href="https://threejs.org/build/three.js" download target="_blank">https://threejs.org/build/three.js</a></li>
                        <li>Ajoutez le dans le dossier de votre projet</li>
                        <li>Chargez le dans votre HTML avant votre script</li>
                    </ul>
                    <div class="code-steps" data-type="html" data-trim>
                        <pre contenteditable><code>
&lt;script src="three.js"&gt;&lt;/script&gt;
                        </code></pre>
                    </div>
                    <p>‚ö†Ô∏è Vous n'aurez pas acc√®s √† toutes les fonctionnalt√©s</p>
                </section>

                <section>
                    <p>Ce cours a √©t√© r√©alis√© avec la version <span class="hl">112</span> de Three.js</p>
                </section>

                <section>
                    <h2>Composition</h2>
                </section>

                <section>
                    <ul>
                        <li>Une <span class="u">sc√®ne</span></li>
                        <li>Des <span class="u">objets</span> dans cette sc√®ne</li>
                        <li>Une <span class="u">cam√©ra</span> (angle de vue, orthographie ou perspective, distance min et max, zoom, etc.)</li>
                        <li>Un <span class="u">moteur de rendu</span> qui va se baser sur les param√®tres de la cam√©ra et sur la sc√®ne pour en d√©duire une <span class="u">image 2D</span> qui s'affichera dans un canvas</li>
                    </ul>
                </section>

                <section>
                    <p>On parle de projection</p>
                    <img src="src/img/projection.png" alt="">
                </section>

                <section>
                    <p>Ces projections et calculs sont faits dans des programmes appel√© shaders (en GLSL) et envoy√©s √† la carte graphique</p>
                    <p>Nous pouvons cr√©er nos propres programmes, mais nous commencerons par utiliser ceux de Three.js</p>
                </section>

                <section>
                    <p>A partir de maintenant, nous emploierons les termes anglais</p>
                    <ul>
                        <li><span class="hl">sc√®ne</span> => scene</li>
                        <li><span class="hl">cam√©ra</span> => camera</li>
                        <li><span class="hl">geometrie</span> => geometry</li>
                        <li><span class="hl">mati√®re</span> => material</li>
                        <li><span class="hl">objets</span> => mesh</li>
                        <li><span class="hl">moteur de rendu</span> => renderer</li>
                    </ul>
                </section>

                <section>
                    <p>Nous allons commencer par cr√©er une sc√®ne simple, puis nous √©tudierons ensuite ce qu'il est possible de faire plus en d√©tail</p>
                </section>

                <section>
                    <h3>Scene</h3>
                    <p>La <span class="u">scene</span> a pour simple objectif de contenir les diff√©rentes <span class="u">meshes</span></p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Scene
 */
const scene = new THREE.Scene()
                        </code></pre>
                    </div>
                </section>

                <!-- <section>
                    <h3>Camera</h3>
                    <p>Il existe plusieurs types de <span class="u">cameras</span>, mais deux sont √† retenir</p>
                    <ul>
                        <li><a href="https://threejs.org/docs/index.html#api/cameras/OrthographicCamera" target="_blank">Orthographique</a> : Sans perspective (isom√©trique)</li>
                        <li><a href="https://threejs.org/docs/index.html#api/cameras/PerspectiveCamera" target="_blank">Perspective</a> : Avec perspective</li>
                    </ul>
                </section>

                <section>
                    <img src="src/img/orthographic-perspective-comparaison.png" alt="" class="no-style">
                </section> -->

                <section>
                    <h3>Camera</h3>
                    <p>Nous allons utiliser une <span class="u">camera</span> avec perspective dont les param√®tres sont les suivants</p>
                    <ul>
                        <li>Field of view : angle de vue en degr√©s</li>
                        <li>Aspect : rapport largeur par hauteur</li>
                    </ul>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Sizes
 */
const sizes = {}
sizes.width = window.innerWidth
sizes.height = window.innerHeight

/**
 * Camera
 */
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
camera.position.z = 3
scene.add(camera)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h3>Mesh</h3>
                    <p>Une <span class="u">mesh</span> se compose d'une <span class="u">geometry</span> et d'un <span class="u">material</span></p>
                </section>

                <section>
                    <p>Geometry</p>
                    <ul>
                        <li>Une <span class="u">geometry</span> se compose de faces (ou triangles)</li>
                        <li>Une face se compose de vertices (vertex en anglais)</li>
                    </ul>
                </section>

                <section>
                    <img src="src/img/faces-vertex.png" alt="" class="no-style">
                </section>

                <section>
                    <p>Three.js poss√®de de nombreuses <span class="u">geometries</span> pr√©-faites</p>
                    <ul>
                        <li><a href="https://threejs.org/docs/#api/geometries/BoxGeometry" target="_blank">Box</a></li>
                        <li><a href="https://threejs.org/docs/#api/geometries/SphereGeometry" target="_blank">Sphere</a></li>
                        <li><a href="https://threejs.org/docs/#api/geometries/CylinderGeometry" target="_blank">Cylinder</a></li>
                        <li><a href="https://threejs.org/docs/#api/geometries/PlaneGeometry" target="_blank">Plane</a></li>
                        <li>Etc.</li>
                    </ul>
                </section>

                <section>
                    <p>Faisons une Box</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
const geometry = new THREE.BoxGeometry(1, 1, 1)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Material</p>
                    <p>Le <span class="u">material</span> va d√©finir quelle doit √™tre la couleur √† appliquer √† chaque pixel visible de la <span class="u">geometry</span></p>
                    <p>Cette couleur peut varier selon un code hexadecimal, des lumi√®res, une image, etc. ou ce peut √™tre une simple couleur unie</p>
                </section>

                <section>
                    <p>Three.js poss√®de de nombreux <span class="u">material</span>, mais nous allons commencer avec le plus simple <a href="https://threejs.org/docs/#api/materials/MeshBasicMaterial" target="_blank">MeshBasicMaterial</a></p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Et enfin, cr√©ons une <span class="u">mesh</span> √† partir de la <span class="u">geometry</span> et du <span class="u">material</span> que nous rajoutons √† la <span class="u">scene</span></p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
const mesh = new THREE.Mesh(geometry, material)
scene.add(mesh)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Tout en m√™me temps</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Object
 */
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
const mesh = new THREE.Mesh(geometry, material)
scene.add(mesh)
                        </code></pre>
                    </div>
                    <p>La cr√©ation d'une mesh se fera presque toujours de cette mani√®re</p>
                </section>

                <section>
                    <h3><span class="u">Renderer</span></h3>
                    <p>Enfin, nous souhaitons r√©cup√©rer ce que voit la <span class="u">camera</span> et l'afficher dans un canvas</p>
                    <p>C'est le role du <span class="hl">renderer</span></p>
                    <p>Celui-ci va lui m√™me cr√©er le canvas que nous rajouterons au <span class="hl">body</span></p>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer()
renderer.setSize(sizes.width, sizes.height)
document.body.appendChild(renderer.domElement)
renderer.render(scene, camera)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h3>Tester</h3>
                    <p>Ouvrez <span class="hl">index.html</span> dans votre browser</p>
                    <p>Vous devriez voir un carr√© rouge sur fond noir</p>
                    <p>Ceci est votre premier rendu WebGL avec Three.js</p>
                    <img src="src/img/clap.gif" alt="">
                </section>

                <section>
                    <p>Le canvas ne prend pas tout le viewport et peut faire appara√Ætre des scrollbars</p>
                    <p>Pour une exp√©rience plein √©cran, rajoutez le CSS suivant</p>
                    <div class="code-steps" data-type="css" data-trim>
                        <pre contenteditable><code>
*
{
    margin: 0;
    padding: 0;
}

html,
body
{
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

canvas
{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h2>Animation</h2>
                </section>

                <section>
                    <p>Nous souhaiterions faire tourner notre <span class="u">mesh</span> et faire bouger la <span class="u">camera</span></p>
                    <p>L'id√©e est de cr√©er une fonction qui sera appel√©e √† chaque frame. Dans cette fonction, nous allons ensuite mettre √† jour la sc√®ne et faire un rendu</p>
                    <p>Pour cela nous allons utiliser <span class="hl fragment">requestAnimationFrame</span></p>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Loop
 */
const loop = () =>
{
    window.requestAnimationFrame(loop)

    // Render
    renderer.render(scene, camera)
}

loop()
                        </code></pre>
                    </div>
                </section>

                <!-- <section>
                    <p>Nous allons faire bouger la <span class="u">camera</span> en fonction du curseur</p>
                    <p>Pour cela, nous allons √©couter l'√©v√©nement <span class="u">mousemove</span> et enregistrer la position de la souris dans un objet <span class="u">cursor</span> qui nous servira plus tard</p>
                </section> -->

                <!-- <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Cursor
 */
const cursor = { x: 0.5, y: 0.5 }
window.addEventListener('mousemove', (event) =>
{
    cursor.x = event.clientX / sizes.width - 0.5
    cursor.y = event.clientY / sizes.height - 0.5
})
                        </code></pre>
                    </div>
                </section> -->

                <section>
                    <p>Difficile de dire si √ßa fonctionne puisque rien ne bouge dans la sc√®ne ü§î</p>
                    <p>Nous devons donc faire bouger notre objet</p>
                </section>

                <section>
                    <p>Les <span class="u">meshes</span> peuvent √™tre manipul√©es √† l'aide des propri√©t√©s <span class="u">position</span>, <span class="u">rotation</span> et <span class="u">scale</span></p>
                    <p>Chacune de ces propri√©t√©s s'appelle un <a href="https://threejs.org/docs/#api/math/Vector3" target="_blank">Vector3</a> et poss√®de les propri√©t√©s <span class="u">x</span>, <span class="u">y</span> et <span class="u">z</span> correspondant aux axes</p>
                    <p>La cam√©ra peut aussi √™tre manipul√©e ainsi</p>
                </section>

                <!-- <section>
                    <p>Position</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
mesh.position.x = cursor.x * 3
mesh.position.y = - cursor.y * 3
                        </code></pre>
                    </div>
                </section> -->

                <!-- <section>
                    <p>Rotation</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
mesh.rotation.x = cursor.y * 3
mesh.rotation.y = cursor.x * 3
                        </code></pre>
                    </div>
                </section> -->

                <!-- <section>
                    <p>Scale</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
mesh.scale.x = cursor.x * 3
mesh.scale.y = cursor.y * 3
                        </code></pre>
                    </div>
                </section> -->

                <!-- <section>
                    <p>Nous allons faire tourner la mesh en permanence, faire bouger la camera en fonction du curseur et forcer la camera √† regarder le centre de la sc√®ne</p>
                    <p>LookAt permet de diriger l'objet vers un vecteur. Nous pouvons utiliser la position de la sc√®ne.</p>
                </section> -->

                <section>
                    <p>Pour commencer, faisons simplement tourner le cube</p>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Loop
 */
const loop = () =>
{
    window.requestAnimationFrame(loop)

    // Update mesh
    mesh.rotation.y += 0.01

    // Render
    renderer.render(scene, camera)
}

loop()
                        </code></pre>
                    </div>
                </section>

                <!-- <section>
                    <h3>Construisez une maison !</h3>
                </section>

                <section>
                    <p>Three.js permet de cr√©er des objets vides pouvant servir de container</p>
                    <p>Cela permet de les transformer plus facilement</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
const house = new THREE.Object3D()
scene.add(house)

const walls = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 1, 1.5),
    new THREE.MeshBasicMaterial({ color: 0xffcc99 })
)
house.add(walls)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Maison compl√®te</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * House
 */
const houseGroup = new THREE.Group()
scene.add(houseGroup)

const grass = new THREE.Mesh(
    new THREE.PlaneGeometry(15, 15, 1, 1),
    new THREE.MeshBasicMaterial({ color: 0x66bb66 })
)
grass.rotation.x = - Math.PI * 0.5
houseGroup.add(grass)

const walls = new THREE.Mesh(
    new THREE.BoxGeometry(5, 2.5, 5, 1, 1, 1),
    new THREE.MeshBasicMaterial({ color: 0xffcc99 })
)
walls.position.y = 1.25
houseGroup.add(walls)

const roof = new THREE.Mesh(
    new THREE.ConeGeometry(4.1, 1, 4),
    new THREE.MeshBasicMaterial({ color: 0x885522 })
)
roof.position.y += 2.5 + 1 * 0.5
roof.rotation.y += Math.PI * 0.25
houseGroup.add(roof)

const door = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 2, 1),
    new THREE.MeshBasicMaterial({ color: 0xff8866 })
)
door.position.x = - 2.5
door.position.y = 1
houseGroup.add(door)

const bush1 = new THREE.Mesh(
    new THREE.SphereGeometry(0.5, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0x228833 })
)
bush1.position.x = - 2.8
bush1.position.z = 1
bush1.position.y = 0.2
houseGroup.add(bush1)

const bush2 = new THREE.Mesh(
    new THREE.SphereGeometry(0.4, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0x228833 })
)
bush2.position.x = - 2.8
bush2.position.z = - 0.8
bush2.position.y = 0.15
houseGroup.add(bush2)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <img width="600" src="src/img/cheers.jpg" alt="">
                </section>

                <section>
                    <h2>Lumi√®res</h2>
                </section>

                <section>
                    <p>La gestion des lumi√®res est tr√®s gourmande en performance</p>
                    <p>Pour fonctionner, nous devons utiliser des <span class="u">materials</span> r√©agissant √† la lumi√®re et rajouter des lumi√®res</p>
                </section>

                <section>
                    <h3>Mati√®re</h3>
                    <p>Three.js supporte plusieurs types de <span class="u">materials</span></p>
                    <table>
                        <tr>
                            <td><a href="https://threejs.org/docs/index.html#api/materials/MeshBasicMaterial" target="_blank">MeshBasicMaterial</a></td>
                            <td><small>Couleur ou texture ne r√©agissant pas √† la lumi√®re</small></td>
                        </tr>
                        <tr>
                            <td><a href="https://threejs.org/docs/index.html#api/materials/MeshLambertMaterial" target="_blank">MeshLambertMaterial</a></td>
                            <td><small>Couleur ou texture r√©agissant √† la lumi√®re avec un rendu moyen</small></td>
                        </tr>
                        <tr>
                            <td><a href="https://threejs.org/docs/index.html#api/materials/MeshPhongMaterial" target="_blank">MeshPhongMaterial</a></td>
                            <td><small>Couleur ou texture r√©agissant √† la lumi√®re avec un rendu de meilleure qualit√© mais moins performant</small></td>
                        </tr>
                        <tr>
                            <td><a href="https://threejs.org/docs/index.html#api/materials/MeshStandardMaterial" target="_blank">MeshStandardMaterial</a></td>
                            <td><small>Comme MeshPhongMaterial, mais avec des param√®tres <span class="u">physically based</span></small></td>
                        </tr>
                    </table>
                </section>

                <section>
                    <p><span class="u">Physically based</span> correspond √† une volont√© de baser les param√®tres d'une entit√© sur des valeurs physique proche de la r√©alit√©</p>
                    <p>Exemples: gravit√©, force du vent, composition d'une mati√®re, etc.</p>
                </section>

                <section>
                    <p>Nous allons remplacer <span class="hl">MeshBasicMaterial</span> par <span class="hl">MeshStandardMaterial</span> et rajouter du metalness et du rougness en param√®tres</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/* ... */
    new THREE.MeshStandardMaterial({ color: 0x66bb66, metalness: 0.3, roughness: 0.8 })
/* ... */
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Nos objets ont disparu, mais c'est normal</p>
                    <p><span class="hl">MeshStandardMaterial</span> se basant sur la lumi√®re, il faut rajouter ces lumi√®res</p>
                </section>

                <section>
                    <p>Three.js supporte plusieurs types de lumi√®res ayant des zones d'action diff√©rentes</p>
                    <ul>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/AmbientLight" target="_blank">AmbientLight</a> : G√©n√©ral</li>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/DirectionalLight" target="_blank">DirectionalLight</a> : Dans une direction venant de l'infini</li>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/HemisphereLight" target="_blank">HemisphereLight</a> : G√©n√©ral, mais avec une distinction entre le sol et le ciel</li>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/PointLight" target="_blank">PointLight</a> : Provenant d'un point</li>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/RectAreaLight" target="_blank">RectAreaLight</a> : Rectangle infini</li>
                        <li><a href="https://threejs.org/docs/index.html#api/lights/SpotLight" target="_blank">SpotLight</a> : Cone</li>
                    </ul>
                </section>

                <section>
                    <p>Nous allons utiliser une <a href="https://threejs.org/docs/index.html#api/lights/PointLight" target="_blank">PointLight</a> que nous allons mettre au dessus de la porte, une <a href="https://threejs.org/docs/index.html#api/lights/DirectionalLight" target="_blank">DirectionalLight</a> pour imiter l'illumitation du soleil et une <a href="https://threejs.org/docs/index.html#api/lights/AmbientLight" target="_blank">AmbientLight</a> pour √©clairer les faces cach√©es</p>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Lights
 */
const doorLight = new THREE.PointLight()
doorLight.position.x = -1.02
doorLight.position.y = 0
doorLight.position.z = 0
house.add(doorLight)

const ambientLight = new THREE.AmbientLight(0x555555)
scene.add(ambientLight)

const sunLight = new THREE.DirectionalLight(0xffffff, 0.6)
sunLight.position.x = 1
sunLight.position.y = 1
sunLight.position.z = 1
house.add(sunLight)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h2>Ombres</h2>
                </section>

                <section>
                    <p>Les ombres ont toujours √©t√© un challenge pour la 3D temps r√©el. M√™me aujourd'hui, avec les cartes graphiques actuelles, les d√©veloppeurs doivent faire preuve d'ing√©niosit√© pour afficher des ombres</p>
                    <p>Three.js int√®gre une gestion basique et peu r√©aliste des ombres</p>
                </section>

                <section>
                    <p>Nous devons avertir le renderer que des ombres vont √™tre utilis√©es</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
renderer.shadowMap.enabled = true
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Nous devons ensuite avertir si chaque objet (Mesh) doit g√©n√©rer une ombre (<span class="u">castShadow</span>) et/ou recevoir des ombres (<span class="u">receiveShadow</span>)</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
walls.castShadow = true
walls.receiveShadow = true
                        </code></pre>
                    </div>
                    <p>Il est important de n'activer les ombres que sur les objets le n√©cessitant</p>
                </section>

                <section>
                    <p>Nous devons enfin avertir chaque lumi√®re si elle doit g√©n√©rer des ombres</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
doorLight.castShadow = true

/* ... */

sunLight.castShadow = true
sunLight.shadow.camera.top = 1.20
sunLight.shadow.camera.right = 1.20
sunLight.shadow.camera.bottom = -1.20
sunLight.shadow.camera.left = -1.20
                        </code></pre>
                    </div>
                    <p>Notre DirectionalLight n√©cessite quelques autres param√®tres afin de fonctionner</p>
                </section> -->

                <!-- <section>
                    <h2>Textures</h2>
                </section>

                <section>
                    <p>Pour plus de r√©alisme, il vaut mieux utiliser des <span class="u">textures</span></p>
                    <p><a href="https://threejs.org/docs/#api/textures/Texture" target="_blank">Texture</a> est l'objet permettant de cr√©er soi-m√™me une texture dans Three.js, mais <a href="https://threejs.org/docs/#api/loaders/TextureLoader" target="_blank">TextureLoader</a> automatise le processus</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Textures
 */
const textureLoader = new THREE.TextureLoader()

const grassTexture = textureLoader.load('grass.jpg')
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Une fois la <span class="u">texture</span> cr√©√©e, il suffit de l'ajouter dans l'attribut <span class="u">map</span> de <span class="u">MeshStandardMaterial</span></p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(4, 4, 1, 1),
    new THREE.MeshStandardMaterial({ map: grassTexture, metalness: 0.3, roughness: 0.8 })
)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h3 style="color:red;">Attention</h3>
                    <p>Le chargement de textures ne fonctionnera pas en local sur Chrome sans lancer un serveur pour des raisons de s√©curit√©</p>
                </section>

                <section>
                    <p>Il est possible de manipuler la texture, par exemple en lui indiquant de se r√©p√©ter un certain nombre de fois</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
grassTexture.wrapS = THREE.RepeatWrapping
grassTexture.wrapT = THREE.RepeatWrapping
grassTexture.repeat.set(4, 4)
                        </code></pre>
                    </div>
                </section> -->

                <section>
                    <h2>Resize</h2>
                </section>

                <section>
                    <p>Actuellement, si vous redimensionnez la fen√™tre, le canvas conserve la m√™me taille</p>
                    <p>Nous devons √©couter l'√©v√©nement de resize et mettre √† jour la cam√©ra et le renderer</p>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Resize
 */
window.addEventListener('resize', () =>
{
    // Save width and height
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
})
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h2>Code final</h2>
                </section>

                <section>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
import * as THREE from 'three'

/**
 * Scene
 */
const scene = new THREE.Scene()

/**
 * Sizes
 */
const sizes = {}
sizes.width = window.innerWidth
sizes.height = window.innerHeight

/**
 * Resize
 */
window.addEventListener('resize', () =>
{
    // Update sizes object
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
})

/**
 * Camera
 */
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
camera.position.z = 3
scene.add(camera)

/**
 * Object
 */
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
const mesh = new THREE.Mesh(geometry, material)
scene.add(mesh)

/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer()
renderer.setSize(sizes.width, sizes.height)
document.body.appendChild(renderer.domElement)

/**
 * Loop
 */
const loop = () =>
{
    window.requestAnimationFrame(loop)

    // Update mesh
    mesh.rotation.y += 0.01

    // Render
    renderer.render(scene, camera)
}

loop()
                        </code></pre>
                    </div>
                </section>

                <!-- <section>
                    <h2>Aller plus loin</h2>
                </section> -->

                <!-- <section>
                    <h3>Shaders</h3>
                    <p>Les shaders sont ces fameux programmes qui sont envoy√©s √† la carte graphique et qui permettent de transformer notre sc√®ne compos√©e d'objets en un rendu 2D</p>
                    <p>Il existe deux types de shaders <span class="hl">vertex</span> et <span class="hl">fragment</span></p>
                </section>

                <section>
                    <p>Vertex</p>
                    <p>Le vertex shader est en charge des vertices</p>
                    <p>Il va permettre d'appliquer une transformation afin d'avoir un effet tel qu'une ondulation pour imiter des vagues</p>
                </section>

                <section>
                    <p>Fragment</p>
                    <p>Le fragment shader est en charge des pixels visibles de la g√©om√©trie</p>
                    <p>Le programme va √™tre ex√©cut√© pour chacun d'entre eux et va permettre de modifier la couleur</p>
                </section>

                <section>
                    <p>Three.js poss√®de un <span class="u">material</span> appel√©e <a href="https://threejs.org/docs/#api/materials/ShaderMaterial" target="_blank">ShaderMaterial</a> permettant d'appliquer des shaders sur une Mesh</p>
                </section>

                <section>
                    <p>Exemple basic de shader (simple boule rouge)</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Shader
 */
const shaderGeometry = new THREE.SphereGeometry(1.5, 46, 46)
const shaderMaterial = new THREE.ShaderMaterial({
    uniforms:
    {
        
    },
    vertexShader:
    `
        void main()
        {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader:
    `
        void main()
        {
            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    `
})
const shaderMesh = new THREE.Mesh(shaderGeometry, shaderMaterial)
scene.add(shaderMesh)
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Exemple de shader plus cool</p>
                    <div class="code-steps" data-type="js" data-trim>
                        <pre contenteditable><code>
/**
 * Shader
 */
const shaderGeometry = new THREE.SphereGeometry(1.5, 46, 46)
const shaderMaterial = new THREE.ShaderMaterial({
    uniforms:
    {
        uTime: { value: 0 }
    },
    vertexShader:
    `
        #define M_PI 3.1415926535897932384626433832795

        uniform float uTime;

        varying vec3 vNormal;
        varying float vOffset;

        void main()
        {
            vec4 modelPosition = modelMatrix * vec4(position, 1.0);

            float offset = 0.0;
            offset += sin(modelPosition.y * 20.0 - uTime * 0.03);
            offset += sin(uv.x * M_PI * 2.0 - uTime * 0.03);
            modelPosition.xyz += normal * offset * 0.1;

            vOffset = offset;

            vNormal = normal;

            gl_Position = projectionMatrix * viewMatrix * modelPosition;
        }
    `,
    fragmentShader:
    `
        varying vec3 vNormal;
        varying float vOffset;

        void main()
        {
            vec3 color = vNormal;
            color += vec3(vOffset * 0.5);

            gl_FragColor = vec4(color, 1.0);
        }
    `
})
const shaderMesh = new THREE.Mesh(shaderGeometry, shaderMaterial)
scene.add(shaderMesh)


/**
 * Loop
 */
const loop = () =>
{
    // ...

    // Shader
    shaderMaterial.uniforms.uTime.value += 1

    // ...
}

loop()
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>Ressources</p>
                    <ul>
                        <li><a href="https://www.shadertoy.com/" target="_blank">Shadertoy</a></li>
                        <li><a href="https://thebookofshaders.com/" target="_blank">The book of shaders</a></li>
                    </ul>
                </section> -->

                <!-- <section>
                    <h3>Particules</h3>
                    <p>Les particules sont tr√®s bien g√©r√©es en WebGL</p>
                    <p>Il est possible d'en afficher des millions sans souci de performance</p>
                    <p>Three.js les g√®re avec <a href="https://threejs.org/docs/#api/objects/Points" target="_blank">Points</a> et <a href="https://threejs.org/docs/#api/materials/PointsMaterial" target="_blank">PointsMaterial</a></p>
                </section> -->

                <!-- <section>
                    <h3>Charger des mod√®les 3D</h3>
                    <p>Three.js permet de charger des mod√®les 3D con√ßu dans des logiciels 3D au format <span class="hl">.obj</span></p>
                    <p>Pour cela, il faut utiliser <a href="https://threejs.org/docs/#examples/loaders/OBJLoader" target="_blank">OBJLoader</a></p>
                </section> -->

                <!-- <section>
                    <h3>Physique</h3>
                    <p>Si vous souhaitez rajouter de la physique dans votre univers 3D, il faut utiliser un moteur de collision</p>
                    <ul>
                        <li><a href="http://www.cannonjs.org/" target="_blank">Canon.js</a></li>
                        <li><a href="https://github.com/kripken/ammo.js/" target="_blank">Ammo.js</a></li>
                    </ul>
                </section> -->

                <section>
                    <h3>Apprendre Three.js</h3>
                    <ul>
                        <li><a href="https://threejs.org/docs/#manual/en/introduction/Useful-links" target="_blank">threejs.org/docs/#manual/en/introduction/Useful-links</a></li>
                        <li><a href="https://threejsfundamentals.org/" target="_blank">threejsfundamentals.org</a></li>
                        <li><a href="https://discoverthreejs.com/book/contents/" target="_blank">discoverthreejs.com/book/contents/</a></li>
                    </ul>
                    <p>Mais la meilleure fa√ßon d'apprendre reste d'exp√©rimenter et d'√©tudier le code des autres</p>
                    <p><a href="https://threejs.org/" target="_blank">Galerie Three.js</a></p>
                    <p><a href="https://threejs.org/examples/" target="_blank">Exemples Three.js</a></p>
                </section>

                <!-- <section>
                    <h3>Piste d'am√©lioration</h3>
                    <ul>
                        <li>Chargement de models</li>
                        <li>Baking</li>
                        <li>Propri√©t√©s de material (bumpMap, displacementMap, emissiveMap, metalnessMap, roughnessMap, etc.)</li>
                        <li>Interactions utilisateur (curseur ou autre)</li>
                        <li>Shaders</li>
                        <li>Post processing</li>
                        <li>Performance</li>
                    </ul>
                </section> -->

                <!-- <section>
                    <h3>Template Three.js</h3>
                    <p>
                        <a href="https://github.com/brunosimon/three.js-template">github.com/brunosimon/three.js-template</a>
                    </p>
                </section> -->

            </div>
        </div>

        <script src="../src/reveal.js/lib/js/head.min.js"></script>
        <script src="../src/reveal.js/js/reveal.js"></script>
        <script src="../src/custom/script.js"></script>

        <!-- Code steps start -->
        <script src="../src/code-steps/prism.js" data-manual></script>
        <!-- Code steps end -->

        <script type="module" src="../src/custom/script-module.js"></script>
    </body>
</html>
